A. SDP/SCP handling

[scamp-isr.c]	eth_rx_int ()
[scamp-3.c]	 eth_receive ()
[scamp-3.c]	  udp_pkt (rx_pkt, rx_len)
[scamp-3.c]	   msg_queue_insert (msg, srce_ip)
[sark_event.c]	    event_queue_proc (proc_route_msg, msg, srce_ip, PRIO_0)

- event_queue_proc allocates an event. It returns FAILURE if it fails
  to allocate a free event.
- msg_queue_insert does *not* check the event_queue_proc return value!

- udp_pkt allocates SDP msg buffer. If it fails to allocate a free msg
  buffer it discards the Ethernet frame and fails silently.

- proc_route_msg sends the return msg if needed. If event_queue_proc
  fails, proc_route_msg never runs and no return msg is sent.

- either udp_pkt, proc_route_msg or return_msg free SDP msg buffer. If
  event_queue_proc fails, proc_route_msg/return_msg never run and the
  SDP msg buffer is not freed!

[sark_event.c]	event_run (restart)
[scamp-3.c]	 proc_route_msg (msg, srce_ip)
		  if (to other chip)
[scamp-3.c]	   p2p_send_msg (msg->dest_addr, msg)
		  else // to this chip
[scamp-3.c]	   scamp_debug (msg, srce_ip)
[scamp-3.c]	  return_msg (msg, rc)



B. SDP windowing problem

1. scamp event handling:
   - asynchronous events are put in event_queue, according to
   priorities. Function event_queue_proc () is used to enqueue.
   event_run () processes the queue.
   - synchronous scheduled events are put in timer_queue,
   according to time of processing. timer_schedule_proc () is
   used to enqueue. timer2_int () processes the queue. Scheduled
   events can be cancelled before they reach their time of
   processing. Note: timer2 does not provide a periodic interrupt.
   It's programmed to interrupt when the next scheduled event should
   happen.

2. These are the events/priority that go into event_queue:
   * proc_route_msg/PRIO_0	msg_queue_insert ()
   * proc_init_cores/PRIO_0	signal_app ()
   * proc_power_down/PRIO_0	signal_app ()
   * proc_stop_app/PRIO_0	signal_app ()
   * level_config/PRIO_0	nn_cmd_sig0 ()
   * proc_start_app/PRIO_0	nn_cmd_ffe ()

   * proc_1khz/PRIO_1		ms_timer_int ()
   * proc_100hz/PRIO_1		ms_timer_int ()

   * proc_1hz/PRIO_2		ms_timer_int ()

3. These are the scheduled events that go into timer_queue:
   * update_load
   * p2pb_nn_send
   * proc_send
   * proc_gather
   * proc_pkt_bc
   * proc_byte_set
   * p2p_open_timeout
   * p2p_ack_timeout
   * p2p_data_timeout
   * p2p_close_timeout

4. event_run (restart) processes events in event_queue according to
priority. Starts at priority 0, processes all events in order, then
does priority 1, and so on, unless restart = 1, which makes it check
the priority 0 queue again every time it finishes any priority
level.

5. This works fine if SDP messages are sent one-at-a-time, i.e., no
windowing is used. This results in low throughput. SDP windowing fails
because scamp runs out of free events and fails to respond, causing
communication with the host to timesout.

6. The problem manifest with restart = 1. If SDP windowing is allowed,
many top-priority SDP events are queued and the queued non-SDP events
(mainly proc_1khz, proc_100hz, proc_1hz) starve, i.e., are never
processed. These accumulate in the queue without being freed, which
leads to running out of free events and, thus, failure.

7. If restart = 0, non-SDP events do not starve and SDP windowing
works correctly but there is very little throughput gain with respect
to non-windowing SDP. This needs better understanding but suggests
that there is too much work to do so real-time deadlines will be
missed:

- Proc_1hz is short and very infrequently called. Unlikely to cause
  problems.

- proc_1khz is short but is the most frequently called. It is likely
  consuming a lot of events that are not freed if it is starving.

- proc_100hz has a lot of work and is frequently called. It is likely
  consuming a lot of events that are not free if it is starving and
  also takes a long time to execute..

8. proc_1hz
   every 1s:
   	 - read PHY_STATUS
   	 - set sv->eth_up

9. proc_100hz
   every 10ms:
   	 - process netinit_phase (boot up only!)
	 - adjust disp_load (led blinking ??) -- this could be in step above.
	 - sample core state: schedule update_load (sark_rand () % 9999)
	 - process iptag timeouts: iptag_timer ()
	 - ping app cpus: soft_sdog ()
	 - send local time-phase control (LTPC) pkt: ff_nn_send ()

10. proc_1khz
   every 1ms:
   	 - blink led0
