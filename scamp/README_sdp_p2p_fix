A. SDP/SCP handling

queue msg
---------
[scamp-isr.c]	eth_rx_int ()
[scamp-3.c]	 eth_receive ()
[scamp-3.c]	  udp_pkt (rx_pkt, rx_len)
[scamp-3.c]	   msg_queue_insert (msg, srce_ip)
[sark_event.c]	    event_queue_proc (proc_route_msg, msg, srce_ip, PRIO_0)

process msg
-----------
[sark_event.c]	event_run (restart)
[scamp-3.c]	 proc_route_msg (msg, srce_ip)
		  if (to other chip)
[scamp-3.c]	   p2p_send_msg (msg->dest_addr, msg)
		  else // to this chip
[scamp-3.c]	   scamp_debug (msg, srce_ip)
[scamp-3.c]	  return_msg (msg, rc)

- udp_pkt allocates an SDP msg buffer. If it fails to allocate one it
  discards the Ethernet frame and fails silently.

- event_queue_proc allocates an event. It returns FAILURE if it fails
  to allocate one. msg_queue_insert does *not* check the
  event_queue_proc return value so it also fails silently.

- proc_route_msg processes the received msg and sends a return msg if
  needed. If event_queue_proc fails, proc_route_msg never runs and no
  return msg is sent.

- event_run frees the allocated event.

- either udp_pkt, proc_route_msg or return_msg frees the SDP msg
  buffer. If event_queue_proc fails, proc_route_msg/return_msg never
  run and the SDP msg buffer is not freed!


B. SDP windowing problem

1. scamp event handling:
   - asynchronous events are put in event_queue, according to
   priorities. Function event_queue_proc () is used to enqueue.
   event_run () processes the queue.
   - synchronous scheduled events are put in timer_queue,
   according to time of processing. timer_schedule_proc () is
   used to enqueue. timer2_int () processes the queue. Scheduled
   events can be cancelled before they reach their time of
   processing. Note: timer2 does not provide a periodic interrupt.
   It's programmed to interrupt when the next scheduled event should
   happen.

2. These are the events/priority that go into event_queue:
   * proc_route_msg/PRIO_0	msg_queue_insert ()
   * proc_init_cores/PRIO_0	signal_app ()
   * proc_power_down/PRIO_0	signal_app ()
   * proc_stop_app/PRIO_0	signal_app ()
   * level_config/PRIO_0	nn_cmd_sig0 ()
   * proc_start_app/PRIO_0	nn_cmd_ffe ()

   * proc_1khz/PRIO_1		ms_timer_int ()
   * proc_100hz/PRIO_1		ms_timer_int ()

   * proc_1hz/PRIO_2		ms_timer_int ()

- Proc_1hz is short and very infrequently called. Unlikely to cause
  problems.

- proc_1khz is short but is the most frequently called. It is likely
  to consume a lot of events that are not freed if it starves.

- proc_100hz has a lot of work and is frequently called. It is likely
  to consume a lot of events that are not freed if it starves and
  also takes a long time to execute.

3. proc_1hz
   every 1s:
   	 - read PHY_STATUS
   	 - set sv->eth_up

4. proc_100hz
   every 10ms:
   	 - process netinit_phase (boot up only!)
	 - adjust disp_load (led blinking ??) -- this could be in step above.
	 - sample core state: schedule update_load (sark_rand () % 9999)
	 - process iptag timeouts: iptag_timer ()
	 - ping app cpus: soft_sdog ()
	 - send local time-phase control (LTPC) pkt: ff_nn_send ()

5. proc_1khz
   every 1ms:
   	 - blink led0

6. These are the scheduled events that go into timer_queue:
   * update_load
   * p2pb_nn_send
   * proc_send
   * proc_gather
   * proc_pkt_bc
   * proc_byte_set
   * p2p_open_timeout
   * p2p_ack_timeout
   * p2p_data_timeout
   * p2p_close_timeout

7. event_run (restart) processes events in event_queue according to
priority. Starts at priority 0, processes all events in order, then
does priority 1, and so on, unless restart = 1, which makes it check
the priority 0 queue again every time it finishes any priority
level.

8. This works fine if SDP messages are sent one-at-a-time, i.e., no
windowing is used. This results in low throughput. SDP windowing fails
because scamp runs out of free events and fails to respond, causing
communication with the host to timesout.

9. The problem manifest with restart = 1. If SDP windowing is allowed,
many top-priority SDP events are queued and the queued non-SDP events
(mainly proc_1khz, proc_100hz, proc_1hz) starve, i.e., are never
processed. These accumulate in the queue without being freed, which
leads to running out of free events and, thus, failure.

10. If restart = 0, non-SDP events do not starve and SDP windowing
works correctly but there is very little throughput gain with respect
to non-windowing SDP. This seems to be caused by going to WFI after
completion of event_run. This function will not be called again until
a new interrupt arrives. If the priority 0 queue has events, there may
not be a new interrupt at this level, which means that these events
will not be serviced until a timer-related interrupt happens.
